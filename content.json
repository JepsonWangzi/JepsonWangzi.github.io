{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-04-22T14:16:23.000Z","updated":"2018-04-22T14:24:14.295Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"MVC ：是一种软件架构模式，也有人叫设计模式，按照MVC规则将代码进行拆分之后，有利与代码的解耦，维护。 M:model 和数据相关的所有代码都是M层的代码V：View 和展示相关的所有的代码都是V层的代码C:Controler M层和V层进行数据交换的桥梁MVP:P presenterMVVM:VM view-model 双向数据绑定 如果 v-model用在复选框上，绑定数据上有两种值1：布尔值：可以控制复选框的选中状态2：数组：当选中复选框的时候，复选框的value值会存入数组中 用在下拉框的时候，绑定的是value值 总结：表单用在数据提交的时候（双向绑定），获取表单得分值一定是通过绑定数据实现的。 插值表达式{ }；可以只能放js的任何表达式 要有结果才行 object.defineProperty:方法添加属性var obj={‘name’:};object.defineProperty(obj,’name’,{ 属性的设置访问器：不能和write set:function{ （ ） };。会在属性被赋值的时候自动调用get:function{ （ ） }:会在属性被获取值的时候自动调用})双向绑定原理：元素变化，数据变化，数据变化，元素也变化ie8一下为什么不支持双向绑定？因为ie8一下没有object.defineProperty这个方法，vue的原理就是这个Vue.set动态添加的数据是可以实现绑定的；Vue.get(vm) Object.defineProperty(obj, “name”, {set: function(value){this._name = value;// 这个方法一被调用，就证明属性发生变化了// 属性一变， html元素就要变// 在这里写代码更新html元素就可以达到双向绑定的效果了document.querySelector(“#txt”).value = this._name;},get: function(){return this._name;}}) v-bind 指令当需要给HTML标签中的属性绑定数据的时候，我吗不能用插值语句，需要用bind 《img v-bind:src=” “》 语法：v-bind：属性名=“要绑定的数据”简写 ： ：属性名=“要绑定的数据” v-bind还可以绑定对象，在对象中属性值是给对象添加的类名，值是Boolean值 代表是否使用v-bind还可以绑定数组，在数组中可以写入类名，绑定是数组里得分数据都生效，也可以和对象联合使用，改变Boolean值 也可以把定义好的对象和数组直接写到bind里面，直接修改Boolean值 v-bind绑定行内样式：1：可以直接写入绑定的数据名字2：可以绑定对象 传入多个属性 vue中的注册事件：v-on:事件名称=”函数名“ 简写 @事件名称=”函数名“函数名：在vue里创建 methods 里面写函数名及方法如何从methods中拿到data中的数据: 通过原型中找就🆗了 vm.属性 假如拿到的是数字，需要转换为number类型的数据1:当注册事件的时候，绑定的内容可以是函数名，也可以是函数名加上小括号，类似于调用，但是不是调用，可以用来传参如果是函数名加小括号，那么在事件触发的时候，可以传参当还需要事件对象的 时候，参数后面继续传参，vue规定好的是$event;2:只是函数名的时候，不能传参，但是在vue定义的函数中获取到事件对象 e;vue中dom更新是异步的，数据改变时候并不代表页面中的内容就更新了，vue是延迟之后执行的，为了防止页面的重绘，vue会等到一个程序，改了很多东西时，在执行，这样会减少页面的重绘和性能，所有dom更新会有延迟vue提供了一个方法，确保dom跟新完成执行的方法this.$nextTick 异步更新队列 this.$nextTick(function(){这个里面执行dom更新执行的操作，因为vue是异步的}) 事件修饰符：可以给事件加上一些特定的功能：用法 v-on：事件名称.事件修饰符=”事件函数“stop：如果给事件加上了stop会阻止冒泡；prevent: 阻止事件的默认行为，例如a连接的默认行为跳转once：事件只触发一次self：事件只能自己触发capture:事件会在捕获阶段被触发如果即向不冒泡和跳转 点下去就行v-on:click.stop.precent=”事件函数” vue中的列表渲染：v-for=”item in ‘数组名’“ item用插值表达式表示 因为是遍历，所以插值表达式还可以写index；直接可以写键值对，循环的次数； .png)遍历指定的数字， 1到100； 遍历数组：.png) v-for 通常需要配合key的使用：当想往数组里添加某一项的时候，效率低下，会替换掉原本插入数组的值，并且下面的都会改变所以有了key 绑定死，增加效率。 key需要一个唯一值，一般情况下，我们都给他绑定index； 总结：1：用v-model在复选框上得到时候，可以用空数组表示，当在浏览器选中的时候，数组的长度就会发生变化2：用v-moel绑定下拉框的时候，绑定selec标签，绑定的是默认数字0，表示默认选中的是第一个元素绑定属性的时候，v-bind：属性=”数据“ 这是简写 这是完整的写发获取某张图片；3：给盒子设置类的属性的时候，可以是一个数组，可以是一个对象，对象的话是键值对形式存在的，值是Boolean值，表示用不用。也可以是一个数组里得分值，只设置一个 4：vue更新数据是异步的，在改变原来的数据时候页面发生了变化，但是没有改，这个时候需要一个方法监听改完了的事件this.$nextTick写在点击事件或者其他事件的后面里面； 5：v-on事件可以简写@时间名=”事件函数名“ 不代括号的 可以在methods的事件中拿到事件event假如带括号的话，在methods里面拿不到，但是可以在v-on的函数名里面传参数，$event 然后在methods的事件里接收一下就🆗；"},{"title":"about","date":"2018-04-22T14:35:32.000Z","updated":"2018-04-22T14:46:20.980Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"To Be cotining………"}],"posts":[{"title":"浮动总结","slug":"浮动总结","date":"2018-05-08T12:39:30.000Z","updated":"2018-05-08T12:43:09.015Z","comments":true,"path":"2018/05/08/浮动总结/","link":"","permalink":"http://yoursite.com/2018/05/08/浮动总结/","excerpt":"","text":"##清除浮动是清除浮动带来的影响！ 起因：拖标的子元素撑不开父盒子的高度，前提父盒子没有设置高度，导致塌陷，在加子盒子的时候，父盒子没有高度。 例如，我假如还要在父盒子下面加一个不托镖的子盒子，排在浮动的下面作为布局（要浮动一起浮动），但是父盒子没有高度的情况下，就跑到和浮动元素一起了，达不到效果，就等于塌陷了！，所以才需要清除浮动。 最核心的原理就是clear both 原理就是 不允许子盒子两边有浮动元素的存在，所以在加标准流，就排到浮动元素下面去了。 ###1 给父盒子加高度 height：xxx; 缺点：高度写死了，不利于下面的布局； ###2 在浮动元素的最后面加一个空盒子，只加一个属性 clear:both; 缺点：浪费一个空盒子； ###3 伪元素法 父盒子：after 就是在父盒子后面加一个伪元素，类似于第二种方法，但是不会浪费资源 12345678910111213141516171819202122232425262728293031323334 .box:after&#123; content:\"\"; 这个一定要写 display:block; clear:both; opacity:hidden; width:0; height:0;&#125;前面三个属性必须加，因为伪元素默认是行内标签，要转化成一个块，可以当作一个盒子了；```` ###4 双伪元素清除法（淘宝，京东就是这样做的，比较保险，因为遇到关于margin塌陷的问题时，双伪元素可以完美的解决）；````css/*不会有margin塌陷*/.clearfix:before,.clearfix:after &#123;content: '';display: table;&#125;.clearfix:after &#123;clear: both;&#125; ###5 触发 bfc 相当于子盒子 怎么翻江倒海，都不会影响到其他元素，只要父盒子触发了bfc就行，内部就不需要清除浮动了！，经常用的是over float hidden； overfloat:hidden 副作用：假如自盒子需要露出外面，就显得很尴尬了（不受外界影响），还是要用clear both; 最常见的就是一个大盒子，左侧子盒子左浮动（宽高写死，右侧自适应的时候），右侧盒子写死高，来一个overflow：hidden ； 就🆗了； 1：float:不为none； 2：overfloat :hidden scoll auto; 3：display table-cell inline-block; 4：position :absolute,fixed;","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[]},{"title":"vuex的使用","slug":"vuex的使用","date":"2018-05-08T12:32:15.000Z","updated":"2018-05-08T12:35:58.843Z","comments":true,"path":"2018/05/08/vuex的使用/","link":"","permalink":"http://yoursite.com/2018/05/08/vuex的使用/","excerpt":"","text":"1：使用npm下载 vue vuex2: 引入vue 和vuex3：在页面上创建实例vm 和vuex的实例 store12345678910111213141516171819202122232425262728const store = new Vuex.Store(&#123;state: &#123;count: 0&#125;,mutations: &#123;increment (state) &#123;state.count+=1&#125;&#125;,getters:&#123;&#125;&#125;)var vm=new Vue(&#123;el:'.app',data:&#123;&#125;,store,methods:&#123;&#125;&#125;)把vuex挂载到vue上，这样所以的组件都能访问vuex的数据 4：这个时候可以实现一些数据的相通了 比如在vue页面访问数据count 使用方法{{$store.state.count}} 结果就是0 5：点击事件获取count 并加1；123456789101112&lt;button @click=\"add\"&gt;666&lt;/button&gt;原本写ad的逻辑会在里面直接获取count并+=1；是例如 this.$store.state.count+=1;但是vuex提供了另一种方法：即 提供给了第二个函数 increment 用它就行了 代码如下methods:&#123;add()&#123;this.$store.commit(\"increment\",10) 固定写法&#125;//这边点击的时候就会执行 increment 里面 方法名字就是 increment 就如不传参的话 结果就是每点击一次加一，传参数的话 在vuex的第二个函数中接收 每次接收加10； 6: 加入要使用一些方法的话就要用的第三个函数 getters 例如点击的时候把count平方12345678910111213141516ping(state)&#123;return state.count *state.count&#125;,数据显示的话 调用方法 $store.getters.ping 即可加入要调用其中一个函数的结果 就可以在函数里传第二个参数了li(state,getters)&#123;return getters.ping * state.count&#125;,这边第二个参数是getters 可以调用里面的函数结果或者方法所以结果就是立方了 显示数据调用方法 $store.getters.li;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"组件","slug":"组件","date":"2018-05-08T12:03:54.000Z","updated":"2018-05-08T12:31:07.106Z","comments":true,"path":"2018/05/08/组件/","link":"","permalink":"http://yoursite.com/2018/05/08/组件/","excerpt":"","text":"组件 定义：是对一个完整功能模块的封装。他里面包含结构样式和行为，html css js. 目的：为了提高代码的可复用性，提高代码可维护性，便于 ####组件：是对功能的封装 ####模块：是对代码的封装 ####最基本的方式注册：1234567891011121314151617181920212223242526271全局：Vue.component( \"模块名\"，&#123; template：\"&lt;div&gt; 这是我人生中的第一个模板 &lt;/div&gt;\" &#125; )调用的时候， 直接写模板的标签即可 &lt;模块名&gt;&lt;/模块名&gt;组件是独立的，他不能使用vm提供的数据，只能自己数据加data数据加的是一个对象 data()&#123; return&#123; msg:hello world' &#125;&#125;data用函数的原因？？因为数据引用在复杂数据类型，用的是地址，不能独立存在，函数的话，可以多次复用，并且每次创建实例的时候互不影响 123456789101112132局部注册：components:&#123;\"wzc\":&#123;template:\"&lt;h1&gt;这是我的第一个组件&lt;/h1&gt;\"&#125;,\"titles\":&#123;template:\"&lt;p&gt;我的第一个段列&lt;/p&gt;\"&#125;&#125; 组件是声明时候被创建的？当我们在页面中使用组建名创建标签的时候，将组件引用的时候。组件就会被创建。 组件之间相互独立，互不影响，数据之间不能直接访问。 ####组件的父子关系： 定义：不是由声明关系确认的假如在vm里写了一个组件，不能说他是vm的儿子。要看被调用的位置 #组件之间的通信 ###一：父到子的通信 1：父组件要把数据传递给子组件的时候，可以把要传递的数据，通过自己的hml标签的属性进行传递，例如传msg数据，自己的组件是father组件,二级组件是son，那么可以12345678&lt;father&gt; &lt;son 自定义名字=”msg“&gt;&lt;/son&gt; &lt;/father&gt;这样父亲就发送了数据给儿子，要不然组件是独立的，拿不到。儿子想要用要引入一种方法在自己的组件中，props：[ 自定义的名字 ]template: ”&lt;son&gt; &#123;&#123; 自定义的名字 &#125;&#125; &lt;/son&gt;“ 2：子组件中，需要声明props数组，在数组中添加对应的属性来接收，子组件在创建的时候，在模板里 绑定数据标签，然后自己就有了数据，可以用了 ###二：子到父的通信； 这边举例和原型VM的传值; ####1:在父组件里声明一个接收数据改变的函数12345methods:&#123; msg(info)&#123; console.log(info) &#125;&#125; ####2：创建子组件过后，在容器写 父亲定义好的数据名（表达式）和子框架要写的函数名123&lt;son @sendmsg=\"msg\"&gt;&lt;/son&gt;这个时候，msg就是在父组件定义好的数据和函数；sendmsg是组件提供的一个方法，在函数里写一种方法传过去 ####3：把数据传给父组件12345678methods:&#123; btn()&#123; this.$emit(\"sendmsg\",\"爸爸看到没有，我发数据给你了\") &#125;&#125;sendmsg在容器里自定义的函数名爸爸看到没有，我发数据给你了：传给父组件的数据 1234567891011121314151617181920212223242526272829&lt;div class=\"app\"&gt;&lt;son @sendmsg=\"msg\"&gt;&lt;/son&gt;&lt;/div&gt;&lt;script&gt;Vue.component(\"son\",&#123; template:\"&lt;div&gt;我是儿子，我要给爸爸发数据&lt;button @click=\"btn\"&gt;send&lt;/button&gt;&lt;/div&gt;\", methods:&#123; btn()&#123; this.$emit(\"sendmsg\",\"爸爸看到没，我发数据给你了\") &#125; &#125;&#125;)var vm=new Vue(&#123; el:'.app', methods:&#123; msg(info)&#123; console.log(info) &#125; &#125;&#125;)&lt;/script&gt; ###三：兄弟之间的通信； 具体弟弟传数据给姐姐 1：创建一个额外的实例，专门作为中转站来传递数据 var center=new Vue(); 2: 姐姐收数据，要定义一个方法 1234567created()&#123;youji.$on(\"sendmsg\",this.getmsg)&#125;youji.$on：固定写法sendmsg: 弟弟调用方法写的函数名getmsg： 接收数据的函数 3：弟弟传数据过去 123456789methods:&#123;btn()&#123;youji.$emit(\"sendmsg\",\"渣比姐姐，给你数据\")&#125;btn：点击时传数据过去youji.$emit：固定写法sendmsg：姐姐定义好的方法名 作为两者的桥梁渣比姐姐，给你数据：传给姐姐的数据 1234567891011121314151617181920212223242526272829var youju=new Vue();Vue.component(\"brother\",&#123; template:\"&lt;div&gt;我是小弟，我要给姐姐发数据&lt;button @click=\"btn\"&gt;send&lt;/button&gt;&lt;/div&gt;\", methods:&#123; btn()&#123; youji.$emit(\"sendmsg\",\"渣比姐姐，给你数据\")&#125;&#125;)Vue.component(\"sister\",&#123; template:\"&lt;div&gt;我是姐姐&lt;/div&gt;\"， methods:&#123; getmsg(info)&#123; console.log(info) &#125; &#125;, created()&#123; youju.$on(\"sendmsg\",this.getmsg) &#125;&#125;)var vm =new Vue(&#123; el:'.app'&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"vue第五部分","slug":"vue第五部分","date":"2018-05-08T11:49:29.000Z","updated":"2018-05-08T11:56:06.188Z","comments":true,"path":"2018/05/08/vue第五部分/","link":"","permalink":"http://yoursite.com/2018/05/08/vue第五部分/","excerpt":"","text":"##路由： 根据不同的hash值，为页面对应显示不同的组件。 路由规则：hash值是如何对应组件的 vue-rooter的使用 1：指定路由规则 2：指定显示的位置 步骤：1：创建vm实例2：创建路由模板3：配置路由的规则，创建路由对象4: 要将路由对象和vm实例关联起来5: 给路由匹配到的组件指定显示的位置 指的就是组件的占位符 12345678910111213141516171819202122232425262728293031321：var vm=new Vue( &#123; el:\".app\" &#125; )2: let Index=&#123;template: '&lt;div&gt;这是首页的内容&lt;/div&gt;'&#125;3: let router=new VueRouter( &#123; routes:[ &#123; path:\"/index\", component:\"Index\" &#125; ] &#125; )4: var vm=new Vue( &#123; el:' ', data:&#123; &#125;, router &#125; ) 5: &lt;router-view&gt;&lt;/router-view&gt; ##路由中参数的获取； 1：用？传递的参数在vue-router的获取 例子： http://xx.com/index.html#/detail?id=123 参数信息 id=123; 获取id； 在创建路由对象的时候可以通过this.$route获取所有信息 //path 路径信息 //hash hash值信息(模拟出来的) //query ?传递的参数信息 //name 路由的名字 //params 路由参数！ 用this.$route.query.id 就可以获取id了； ##路由参数的获取 例子：detail.html#/detail/18/wzc/nan 配置：1234567891011routes: [ &#123; path: \"/detail/:id/:name/:gender\", component: Detail &#125; ]获取id： this.$route.params.id this指的是实例router","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"vue第四部分","slug":"vue第四部分","date":"2018-05-08T11:34:17.000Z","updated":"2018-05-08T11:54:36.085Z","comments":true,"path":"2018/05/08/vue第四部分/","link":"","permalink":"http://yoursite.com/2018/05/08/vue第四部分/","excerpt":"","text":"自定义指令：自己定义的指令起因 ：在vue中需要，不得不要dom操作时，就要使用自定义指令了。 需求：需要页面加载获取input的焦点 focus 1234567891011121314151617181920 全局注册：Vue.directive ( \"指令名称\" ，&#123; &#125; ) 指令名称不用加v-;bind（）&#123;el ,binding&#125;:只执行一次，在第一次被绑定到元素的时候调用inserted（）&#123;&#125;：只执行一次，当指令所在DOM元素被插入其父节点的时候调用；update（）&#123; &#125;：当指令绑定的数据发生变化的时候，就会调用这个函数，dom还没有更新componentUpdated（）&#123; &#125;:数据发生变化，DOM更新之后调用unbind（）&#123; &#125;：解绑指令// el 绑定的dom元素// binding 指令的信息 自定义属性的简写： Vue.directive( &quot;指令名称&quot; function （ el binding ） { 这里面只能写 bind 和update阶段相同代码的情况下写。同时执行。 } ) ####指令的标准格式： 指令名称：参数.修饰符=“表达式” 指令书写的时候。 各个内容都可以用binding拿取到 binding.name 指令的名称 binding.rawName: =冒号左面的所有字符串 binding.expresion: 指令的表达式，是字符串 binding.value:指令的表达式的值 binding.arg:指的是参数信息， 冒号中的信息 binding.modifiers:存的是修饰符信息，所有修饰符都会被当作属性 监视功能：监听数据变化beforeUpdate :可以监听数据变化，但是不知道谁变了； watch：用来监听特定的数据； 12345678910111213 假如数据是msg监听msgwatch:&#123; msg(newValue,oldValue)&#123; 这里面执行数据变化处理的逻辑&#125; &#125;两个参数：是改变之后和之前的值 1234567891011121314151617181920 假如监听的对象里的属性，怎么获取？\"obj.msg\" :function()&#123;&#125;---------------------------------------------------深度监视：obj:&#123;handle（nv,ov）&#123;&#125;,deep:true ----------深度监视开启，默认是falseimmediate：true---------会在监视一生效就直接执行一次，默认是false&#125;obj传对象handle是执行数据变化的函数deep：开启深度监视immediate：开启时就直接执行一次深度监视，不常用 ` 1234567891011121314151617181920212223242526#### computed和waich的区别： ​ computed只是为了提供数据的； ​ watch是需要在数据发生变化的时候做的某些操作#### 动画：* v-enter：* v-enter-to：* v-leave：* v-leave-to： 写多组动画，v可以被替换，需要指定transition的name值； 把要动画的元素用transition标签包裹就可以用了````js &lt;transition enter-active-class=&quot;animated swing&quot; leave-active-class=&quot;animated zoomOutUp&quot;&gt; &lt;div class=&quot;box&quot; v-show=&quot;isShow&quot;&gt;&lt;/div&gt; &lt;/transition&gt; ` 红色：盒子进入和离开的动画 固定写法，动画名可以更改 SP : 单页面应用：整个网站只有一个页面这边一个页面只有一个地址，实现跳转 使用hash值 hash值：url地址中#后面的内容，改变hash值，页面不刷新； 123456window.onhashchange = function()&#123; // alert(location.hash); //根据用户访问的hash值，改变页面上展示的内容 监听hash值的变化，从而改变页面 &#125; vue 实现单页面的跳转 1：把每个网页做成一个组件取好名字 2：创建实例，给页面一个默认的界面 1234&lt;component :is=\"loc\"&gt;&lt;/component&gt;固定写法，component这个标签可以自动读取一个组件loc是默认的数据变量，值为index 页就是首页 3：在created函数里监听hash值的变化jscreated(){ this.loc = location.hash.slice(2); window.onhashchange = () =&gt; { this.loc = location.hash.slice(2); } }","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"vue第三部分","slug":"vue第三部分","date":"2018-05-08T11:23:01.000Z","updated":"2018-05-08T11:33:23.621Z","comments":true,"path":"2018/05/08/vue第三部分/","link":"","permalink":"http://yoursite.com/2018/05/08/vue第三部分/","excerpt":"","text":"vue中的计算属性：computed计算属性是有缓存的。 不可以传参。 computed里面写方法的函数12345简写:fullName()&#123; return this.firstName + '·' + this.lastName; &#125; 这个时候调用的话返回的是两个数字的和 用v-model绑定函数名fullName即可； 123456789101112131415161718192021222324完整写法：可以执行某些操作； 实现双向绑定fullName: &#123; //get方法其实就是给视图提供数据用的 get() &#123; //当要获取这个计算属性的值的时候，就会调用get方法 //get方法的返回值，就是最终获取到的属性值 console.log(\"计算属性的get方法被调用功能了\") return this.firstName + '·' + this.lastName;&#125;&#125;在绑定fullName的时候自动就调用了这些方法set(value) &#123; // 把value也就是当前input标签中的内容拆分开 // 分别给firstname和lastname var names = value.split(\"·\"); this.firstName = names[0]; this.lastName = names[1]; console.log(\"计算属性的set方法被调用功能了\", value) &#125;这个是当视图改变的时候，对视图结果做的一些事情，value传进来的就是视图绑定的结果 vue的生命周期： 1: new Vue 实例诞生 2：初始化了声明周期和生命周期中的事件 3：初始化数据 4：检测是否有el选项 5：检测是否有template选项 6：no, 将el指向的元素的HTML代码编译成模板 7：将模板用数据填充，创建出来了vm.$el (有数据的HTML代码),接着用vm.$el把页面中的el所在位置的元素替换掉了 8：此时页面已将进入了稳定的运行状态了此时开始监听数据的变化当数据发生变化的时候。vue更新页面内容继续监听 9：vue实例不会自然死亡 当我们调用vm.$destory方法的时候 10：卸载所有的数据监听，组建，事件监听 11：vue实例挂了… ####钩子函数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//所有钩子函数的this指向都是指向当前实例vue// 钩子函数的触发顺序和触发时机// 1创建// beforeCreate:初始化数据之前执行的（拿不到数据）// create:初始化数据完成之后执行的（可以拿到数据）// 挂载// beforeMount:当渲染好的页面元素被挂载到了页面之前调用（拿不到数据，dom,拿不到指令，未被解析的）// mounted：当渲染好的页面被挂载到了页面之后调用（可以操作有数据的dom 了）// 更新// beforeUpdate:当有数据发生变化，但dom还为未更新之前调用，此时如果访问dom拿到的内容还是旧内容// updated: 当有数据发生变化，dom也更新完成之后调用，此时如果访问dom拿到的就是新内容了// 销毁// 当vm.$destory方法被调用的时候，vm对象就要销毁了// 销毁指的是功能解除，不再做任何的数据绑定更新操作，但是vm对象还在// beforeDestory:在功能销毁前调用// destoyed: 在功能销毁后调用var vm=new Vue(&#123;el:'#app',data:&#123;msg:'Hello World'&#125;,beforeCreate()&#123;console.log(\"beforeCreate被调用了\", this.msg)&#125;,created()&#123;console.log(\"Create被调用了\", this.msg)&#125;,beforeMount()&#123;console.log(\"beforeMount被调用了\");console.log(document.querySelector(\"#app\").innerHTML);&#125;,mounted()&#123;console.log(\"Mount被调用了\");console.log(document.querySelector(\"#app\").innerHTML);&#125;,beforeUpdate()&#123;console.log(\"beforeUpdate被调用了\");console.log(document.querySelector(\"#app\").innerHTML);&#125;,updated()&#123;console.log(\"Update被调用了\");console.log(document.querySelector(\"#app\").innerHTML);&#125;,beforeDestory()&#123;console.log(\"beforeDestory被调用了\");console.log(document.querySelector(\"#app\").innerHTML);&#125;&#125;) vue过滤器：1234567891011121314151617181920写法： &#123;&#123; msg | 过滤器的名字 &#125;&#125;原理：把msg的数据进行修改显示filters:&#123;add(value)&#123;return value*2;&#125;&#125;add就是过滤器的名字，这个写的是局部过滤器，与全局过滤器同时存在时，会先找局部，再找全局。全局写法：Vue.filter( \"过滤器的名字\" function（value）&#123; &#125; )value：是进行修改的数据 通过参数传进来 键值修饰符：keyup;作用：按下某个键的时候触发事件函数 写法：v-on:keyup.键盘码=&quot;函数名&quot; 简写：@keyup.键盘码=&quot;函数名&quot;; 1例： &lt;input type=\"text\" @keyup.enter=\"hl\"&gt; vue中有默认的键盘码，例如 enter space esc 自定义全局按键：Vue.config.keyCodes.键盘码名字 = 键盘码；","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"vue笔记第二部分","slug":"vue第二部分","date":"2018-05-08T10:57:17.000Z","updated":"2018-05-08T11:18:57.998Z","comments":true,"path":"2018/05/08/vue第二部分/","link":"","permalink":"http://yoursite.com/2018/05/08/vue第二部分/","excerpt":"","text":"渐进式：只包括一些核心的功能，不像重量级angular功能啥都有，需要其他功能的时候，在用插件引入其他功能 #####指令：自定义的HTML标签属性 作用：标记功能，当vue解析HTML代码的时候，遇到vue指令，就会实现特定的功能。 v-show：控制元素的显示隐藏 通过控制元素的display属性控制; 用在切换显示比较频繁的位置 #####v-if： 可以控制元素的展示和隐藏，通过删除和创建元素控制； v-if:用在只要在进入页面之后进行一次判断的场景（管理员模块的显示和隐藏） v-pre ：主要用来跳过没有vue指令的HTML代码，加快效率 v-once用来做性能优化，这个指令所在的元素中所有的vue v-text：插值表达式中如果有HTML标签会被转移之后输出到页面上。不会被解析，可以对照inner text理解 v-html：可以渲染HTML，对照inner HTML理解 vue指定加载存在的问题：在vue被加载之前，所有指令都会被浏览器正常按照HTML渲 染出来，让vue加载完成时，指令才会被解析，然后重新渲染页面，会有闪烁效果。网速查的时候，用户体验不好。 ​ v-clock：解决删除的问题，还有渲染的插值符号在界面上 方法： 使用属性选择器 [ v-clock ] { display: none } ; 原理： 在vue加载之前，属性选择器生效，元素none，vue加载完成的时候，指令被溢出，指令失效，元素也就正常按照指令显示了。 箭头函数： 一：写法 var 函数名=（参数1，参数2）=&gt;{函数体} 二：函数的简写： 1：假如参数只有一个，小括号可以省略，假如没有参数的话 可以用下划线表示 2：假如函数体里就一句话，大括号可以不写； 3：假如函数体里只有一句话，并且这句话还是return语句，那么大括号可以省略； 三：箭头函数的this指向 1：箭头没有自己的this 2：如果在箭头函数中访问this，那么使用的this就是外层作用域中的this 3：箭头函数中this指向不能再使用函数调用模式来分析了！ ​ var age = 20; var obj = { age: 18, func: () =&gt; { //this --&gt; window //这是一个箭头函数，所this要向外找 外层作用域就是全局作用域 //全局作用域中的this是window var f = () =&gt; { //this --&gt; window //这是一个箭头函数，所this要向外找 console.log(this.age); } f(); } } obj.func(); 五：箭头函数没有自己的arguments; 在箭头里如果调用了argums，那么会沿着作用域向上找 六 箭头函数传递不定个数的参数 rest参数：剩余的参数 1234 var sum=(c,b,...a)=&gt;&#123; console.log(a);&#125;sum(2,1,3,4,5,6,7) 打印a结果是[ 3 , 4 ,5 ,6 , 7 ] a就代表rest参数 条件： 1：一个函数只能有一个rest参数 2：rest只能作为参数列表的最后一个参数 ES6 对象；简写： ：function可以省略； 扩展：需要别人对象的方法，在对象里添加（...对象名）","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"vue first Day","slug":"vue第一部分","date":"2018-04-22T14:53:55.000Z","updated":"2018-04-22T15:04:21.887Z","comments":true,"path":"2018/04/22/vue第一部分/","link":"","permalink":"http://yoursite.com/2018/04/22/vue第一部分/","excerpt":"","text":"MVC ：是一种软件架构模式，也有人叫设计模式，按照MVC规则将代码进行拆分之后，有利与代码的解耦，维护。 M:model 和数据相关的所有代码都是M层的代码 V：View 和展示相关的所有的代码都是V层的代码 C:Controler M层和V层进行数据交换的桥梁 MVP:P presenter MVVM:VM view-model 双向数据绑定 双向数据绑定 如果 v-model用在复选框上，绑定数据上有两种值 1：布尔值：可以控制复选框的选中状态 2：数组：当选中复选框的时候，复选框的value值会存入数组中 3 用在下拉框的时候，绑定的是value值 总结：表单用在数据提交的时候（双向绑定），获取表单得分值一定是通过绑定数据实现的。 插值表达式{ }； 可以只能放js的任何表达式 要有结果才行 双向绑定的而原理 object.defineProperty:方法添加属性 123456789var obj=&#123;‘name’:&#125;;object.defineProperty(obj,&apos;name&apos;,&#123; 属性的设置访问器：不能和write set:function&#123; （ ） &#125;;。会在属性被赋值的时候自动调用get:function&#123; （ ） &#125;:会在属性被获取值的时候自动调用&#125;) ###双向绑定原理：元素变化，数据变化，数据变化，元素也变化 ie8一下为什么不支持双向绑定？ 因为ie8一下没有object.defineProperty这个方法，vue的原理就是这个 Vue.set动态添加的数据是可以实现绑定的； Vue.get(vm) 123456789101112Object.defineProperty(obj, &quot;name&quot;, &#123;set: function(value)&#123;this._name = value;// 这个方法一被调用，就证明属性发生变化了// 属性一变， html元素就要变// 在这里写代码更新html元素就可以达到双向绑定的效果了document.querySelector(&quot;#txt&quot;).value = this._name;&#125;,get: function()&#123;return this._name;&#125;&#125;) v-bind 指令 当需要给HTML标签中的属性绑定数据的时候，我吗不能用插值语句，需要用bind 《img v-bind:src=” “》 语法：v-bind：属性名=“要绑定的数据” 简写 ： ：属性名=“要绑定的数据” v-bind还可以绑定对象，在对象中属性值是给对象添加的类名，值是Boolean值 代表是否使用 v-bind还可以绑定数组，在数组中可以写入类名，绑定是数组里得分数据都生效，也可以和对象联合使用，改变Boolean值 也可以把定义好的对象和数组直接写到bind里面，直接修改Boolean值 v-bind绑定行内样式：-1：可以直接写入绑定的数据名字-2：可以绑定对象 传入多个属性 #####vue中的注册事件：v-on:事件名称=”函数名“ 简写 @事件名称=”函数名“ 函数名：在vue里创建 methods 里面写函数名及方法 如何从methods中拿到data中的数据: 通过原型中找就🆗了 vm.属性 假如拿到的是数字，需要转换为number类型的数据 1:当注册事件的时候，绑定的内容可以是函数名，也可以是函数名加上小括号，类似于调用，但是不是调用，可以用来传参 如果是函数名加小括号，那么在事件触发的时候，可以传参 当还需要事件对象的 时候，参数后面继续传参，vue规定好的是$event; 2:只是函数名的时候，不能传参，但是在vue定义的函数中获取到事件对象 e; vue中dom更新是异步的，数据改变时候并不代表页面中的内容就更新了，vue是延迟之后执行的，为了防止页面的重绘，vue会等到一个程序，改了很多东西时，在执行，这样会减少页面的重绘和性能，所有dom更新会有延迟 1234567vue提供了一个方法，确保dom跟新完成执行的方法this.$nextTick 异步更新队列 this.$nextTick(function()&#123;这个里面执行dom更新执行的操作，因为vue是异步的&#125;) #####b 事件修饰符：可以给事件加上一些特定的功能：用法 v-on：事件名称.事件修饰符=”事件函数“12345stop：如果给事件加上了stop会阻止冒泡；prevent: 阻止事件的默认行为，例如a连接的默认行为跳转once：事件只触发一次self：事件只能自己触发capture:事件会在捕获阶段被触发 如果即向不冒泡和跳转 点下去就行 -v-on:click.stop.precent=”事件函数” vue中的列表渲染：v-for=”item in ‘数组名’“ item用插值表达式表示 因为是遍历，所以插值表达式还可以写index； 直接可以写键值对，循环的次数； 遍历指定的数字， 1到100； v-for通常需要配合key的使用：当想往数组里添加某一项的时候，效率低下，会替换掉原本插入数组的值，并且下面的都会改变所以有了key 绑定死，增加效率。key需要一个唯一值，一般情况下，我们都给他绑定index； ###总结： 1：用v-model在复选框上得到时候，可以用空数组表示，当在浏览器选中的时候，数组的长度就会发生变化 2：用v-moel绑定下拉框的时候，绑定selec标签，绑定的是默认数字0，表示默认选中的是第一个元素 绑定属性的时候，v-bind：属性=”数据“ 1234&lt;img :src=&quot;url&quot; alt=&quot;&quot; /&gt; 这是简写&lt;img v-bind:src=&quot;url&quot; alt=&quot;&quot; /&gt; 这是完整的写发获取某张图片； 3：给盒子设置类的属性的时候，可以是一个数组，可以是一个对象，对象的话是键值对形式存在的，值是Boolean值，表示用不用。也可以是一个数组里得分值，只设置一个 4：vue更新数据是异步的，在改变原来的数据时候页面发生了变化，但是没有改，这个时候需要一个方法监听改完了的事件this.$nextTick写在点击事件或者其他事件的后面里面； 5：v-on事件可以简写@时间名=”事件函数名“不代括号的 可以在methods的事件中拿到事件event – 假如带括号的话，在methods里面拿不到，但是可以在v-on的函数名里面传参数，$event 然后在methods的事件里接收一下就🆗；","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"FW切图工具","slug":"FW切图工具","date":"2018-04-22T14:48:34.000Z","updated":"2018-04-22T14:51:24.609Z","comments":true,"path":"2018/04/22/FW切图工具/","link":"","permalink":"http://yoursite.com/2018/04/22/FW切图工具/","excerpt":"","text":"FW简易切图：- 打开文件 ctrl+o 或者直接拖拽进去 - 选择切片工具 K - 把需要的区域量出来 - 通过缩放工具（z）去看看有没有量的很准确 - 通过Q工具（选择里面是缩放）去缩放切片 - 按住空格键不放 鼠标进行拖拽可以移动画布 - 缩小：ctrl + - - 滴管工具：i #####1、ps软件 - 处理位图的一个软件 - 学习的目的： * 1、简单使用ps * 2、重点在于切图 * 3、简单修改设计图 * 4、便于团队沟通 ##### 图层：图层本质上就可以看做是一张一张相同大小透明的纸，一个完整图像本质上是由一个又一个的图层堆叠而成 有了图层可以方便我们去修改，而如果单单只有一张图片处理起来是比较麻烦的 ##### ps的源文件名：psd 保留图层 利于后期修改 图片的文件名：jpg png gif 等 没有图层，不利于修改 #####切片工具：C 量尺寸 量完之后双击切片即可得到宽度和高度，一旦当切片多的情况下，需要选择某一个切片就需要运用到切片选择工具（也是c，但是要切换） - 放大：快捷键 Z 在属性菜单栏下将细微缩放干掉 - 缩小：ctrl + - #####移动工具：V 移动工具 常用 选择图层：v工具状态下，在属性菜单栏下将自动选择勾选去掉 将组改成图层之后，选择对应的图片只需要按住ctrl不放，在图像上单击即可找到对应的图层 吸管：i 吸取的结果会在前景色里面找到。点击前景色即可获取颜色 切片工具：C （选择c工具组里面的某一个 shift+c） #####切图： 选择切片工具将需要切的区域框选出来 调整大小（一定是在c工具状态下） 三键（ctrl+alt+shift）+s（导出web使用格式）一定要选择（选中的切片） 注意：ps会在你选择的目录下找images文件夹，如果没有ps会自己新建一个 删除切片：在c状态下，直接在切片有右键即可删除切片 选择切片：在c状态下，按住ctrl不放 直接点击切片即可选中 #####如何切一张透明的图片： 1、先选中这个图片的图层 （按住ctrl不放 然后点击该图像即可跳到这个图像对应的图层） 2、在改图层上右键转换成智能对象 3、在图层中心范围内双击 点击确定 4、三键+s保存 （这个保存需要将图片文件放到对应的文件夹里面去） 其他了解： 修改单位：ctrl+k 打开首选项 ==&gt; 单位与标尺 ==&gt; 单位面板修改即可 拉辅助线：前提：必须有标尺（ctrl+r）直接从标尺处开始拖拽 新建文件：ctrl+n 分辨率 72 选区工具：m 填充前景色：alt+退格键 填充背景色：ctrl+退格键 缩放的快捷键：ctrl+t 合并图层：ctrl+e 撤销操作：ctrl+alt+z","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[]},{"title":"数组即字符串的常用方法","slug":"数组即字符串的常用方法","date":"2018-04-22T14:41:24.000Z","updated":"2018-04-22T14:45:19.366Z","comments":true,"path":"2018/04/22/数组即字符串的常用方法/","link":"","permalink":"http://yoursite.com/2018/04/22/数组即字符串的常用方法/","excerpt":"","text":"##数组的方法 1：数组的翻转123var arr = [9,8,4,12,45,72,100,120];var newArr = arr.reverse();返回的是反 转后的数组，原来的数组也被翻转了 2：排序1234var sortedArr = arr.sort(function (a, b) &#123;// return a- b; //升序排列return b - a; //降序排列&#125;); 3：数组的拼接123456var arr1 = [1, 2, 3, 4, 5];var arr2 = [&quot;hello&quot;, &quot;hi&quot;, &quot;hehe&quot;];var arr3 = [&quot;嘿嘿&quot;, &quot;哈哈&quot;, &quot;嘻嘻&quot;];var newArr = arr1.concat(arr2,arr3);参数：需要一个或多个数组返回值：拼接后的数组，不改变原数组 4：数组的截取 slice： *不给参数：复制数组 —————————-不改变原有的数组 * 一个参数：下标到最后，包含开始 * 二个参数： 数字都是下标，但是不包括最后的 即 [ ); splice: *不给参数：截取数组—————————–截取数组，改变原数组 * 一个参数：从开始的下标开始截取，一直到最后 *两个参数：从参数一下标截取，截取参数二的个数 *多个参数：参数三以后是在截取的位置添加元素 #####5：数组的查找 indexOf : 查找第一次出现的位置返回值：返回元素的位置 ，找不到返回-1 参数：需要查找的元素 lastIndexOf:查找最后一个：同上 ####数组转化字符串 1 join : 是将数组转换成为字符串，并且使用分隔符链接参数：不给以逗号隔开，传的话参数代表分隔符 返回值：转换成字符串的结果 12345678910练习：数组去重原理：循环数组进行查找元素，没有的话push到新数组var arr = [&quot;c&quot;, &quot;a&quot;, &quot;z&quot;, &quot;a&quot;, &quot;x&quot;, &quot;a&quot;, &quot;a&quot;, &quot;z&quot;, &quot;c&quot;, &quot;x&quot;, &quot;a&quot;, &quot;x&quot;];var newArr=[ ];for( var i = 0; i&lt;arr.length; i++)&#123; if(arr.indexOf(arr[ i ])==-1)&#123; newArr.push( arr[ i ]);&#125;&#125; 字符串去空格：trim（）； 返回的是去掉两边空格的字符串 字符串的复制 substr: 从原有的字符串上复制一段 一个参数：从下标开始复制到最后 两个参数：从参数一的下标开始，复制参数二的个数 返回值： 复制后的字符串 字符串的切割：(把字符串转换成为数组)123 split：var str5 = &apos;hello-hi,你好&apos;;var result = str5.split(&quot;-&quot;);","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[]},{"title":"git命令","slug":"git命令","date":"2018-04-21T15:24:54.000Z","updated":"2018-04-22T14:22:00.484Z","comments":true,"path":"2018/04/21/git命令/","link":"","permalink":"http://yoursite.com/2018/04/21/git命令/","excerpt":"","text":"git 重置 reset –hard 版本号 重置了这个版本，在所有区域都重置了 将来不小心误操作了，提交了，可以回退某个版本 reset –soft 版本号 只重置了仓库区 reset –mixed 版本号 重置，只剩下工作区 把暂存区和仓库区都重置了 1234567 git 忽视文件（有的文件不希望git管理提交）* 在文件目录中创建一个 .gitignore * 把不想提交的文件名写在这个文件里即可* 把自己也写进去 git 分支操作 git branch 查看分支，master是默认的主分支 分支其实本质上就是一个指针 当新提交了一个版本，当前的指针会指向最新生成的版本 当前颜色是绿色，有小菊花 #####创建分支 git branch login 新建一个登陆的分支 git branch 可以查看所有分支 git 中有一个HEAD指针永远指向当前分支 #####切换分支 git checkout login 切换分支为登陆的分支 在这之后，master分支都没有登陆功能，给客户看的时候就不会有bug 当登陆功能写完时，切换master分支 git checkout master 并且希望login的内容合并master分支上 git merge login 这样就何在一起了 #####删除分支 git branch -d login (前提login要切换到其他分支，并合并才能删除) ###创建分支的步骤： 1：在写另一个功能不想被别人看到的时候先创建分支 git branch login 2:要把新建的分支指向这个功能 git chekout login 然后这个时候就可以开始写代码了,然后写的代码包括一开始写的代码（master阶段），如果切换到master分支时，不会显示login分支的内容 3：最后写完了 把分支指向主分支 git checkout master 4:最后要主分支master合并login即可 git merge login 这个时候login的内容和master一开始的内容就合并了 5：这个时候分支就可以删除了 git branch -d login; git checkout -b 分支名 创建并且切换 多个分支合并的冲突问题 git ：当先合并一个的时候，原理是指针会带着master指向那个分支，是祖辈分支可以快速合并，但是在继续合并其他分支的时候，由于分支带着master跑到了其他分支，再合并就不是祖辈关系了，导致合并冲突，不能快速合并 解决方案：删除冲突产生的符号标记，并删除，然后重新add commit 就行了 git对比 查看工作区与暂存区的不同 git diff 查看暂存区与仓库区的不同 git diff –cached 查看工作区与仓库区的不同，HEAD表示最新的那次提交 git diff HEAD 查看两个版本之间的不同 git diff c265262 de4845b ###github常见项目 克隆远程仓库 git clone 仓库地址 文件夹名称 提交到远程仓库 git push +地址 分支名（master） 提交过一次 再次提交可以把地址改为origin就行 （origin是克隆的时候保存下来的） git pull 获取远程仓库可以直接偷过来用 git remote 查看地址的快捷名 git remote add bi别名 给地址增加其他的名字 SSH非对称加密 私钥 个人 公钥 GitHub","categories":[{"name":"git专题","slug":"git专题","permalink":"http://yoursite.com/categories/git专题/"}],"tags":[]},{"title":"前端模块化","slug":"前端模块化","date":"2018-04-21T15:07:24.000Z","updated":"2018-04-22T14:38:24.819Z","comments":true,"path":"2018/04/21/前端模块化/","link":"","permalink":"http://yoursite.com/2018/04/21/前端模块化/","excerpt":"","text":"前端模块化 1 前提在使用模块化之前，在当前页面引入插件require.js 1: 定义模块：语法define（“模块名”，[依赖项]，function（）{ 模块的全部代码cosole(我是A模块哈哈)}） 模块名一般建议不写，叫做匿名模块 还要起名字的叫做（具名模块）； 2:引入模块：语法 require（[模块名，写明路径]），function（）{模块引入完成时调用 执行这里面 的代码（异步）console。log（我是A模块哈哈）}） 模块名不要.js后缀 定义，并且引入过后，主要执行的结果是我是A模块哈哈我是A模块哈哈 但是 由于定于的模块是一个闭包，调用完成后就被销毁了，所以要有一种方法暴露出去 导出 即可。 require（[模块名，写明路径]），function（）{ 模块引入完成时调用 执行 这里面的代码（异步）var age=100; function song(){ alert(6666); return{age:age,song:song }; //这样这个定义的模块就有了导出项，别人可以使用了，但是问题来了，别人怎么使用呢！！！ }） 有导出项的模块怎么使用，即使用返回时，怎么拿到！！！ 在引入模块的回掉函数写一个形参 require（[模块名，写明路径]），function（mk）{ mk.song(); mk.age;}） mk就是一个形参，接收引进了模块暴露的数据，是一个对象 这样模块引进的同时，数据也可以调用 结果就是 6666 100 4：引入多个模块，多个模块都有返回值，怎么解决！！ require（[a,b,c]，function(a.b.c){ }）一般形参和数组中的模块是一一对应的，注意对应和顺序，有几个导出项，就要写几 个形参 一般没有形参的可以用下划线表示 优化，不用返回值的模块因日可以写在后面，这样这个模块的形参在最后就可以不写了!!! 5 依赖项define（“模块名”，[c]，function（mc）{mc.xxxxxxx(就可以用了) }） 假如定义的是b模块 。C是依赖项，想用c的导出项，也是给一个形参 6 模块的路径 一般像jQuery主流的插件 都是有导出项的 支持模块化的 路径很深的情况下不好找，于是有了方法require.config({基础路径：一般是网站的 决定路径；baseUrl:’’paths:{ chajian:’’ chajian2:’’} }) paths:{chajian:’’} 这一部分是的paths是配置的插件的路径 chajian 这是自定义取的别名，防止真正的插件名字太长，可以替换的 后面的是 基础路径设置完成下面的相对路径 然后在导入插件的时候就可以用别名了require（[chajian,chajian2]，function(){ }） 假如有的插件不支持模块化，但是有要依赖项比如 bootstrap 和wangedtor 他俩不 支持但是有依赖与jQuery给不支持模块化的第三方插件使用 require.config({基础路径：一般是网站的决定路径；baseUrl:’’paths:{ chajian:&apos;&apos; chajian2:&apos;&apos;bootstrap:&apos;&apos;wangeidtor} }) shim{ } ##一个项目的总代码1234567891011121314151617181920212223242526 1配置路径require.config(&#123; 2公共的基础路径baseUrl:&apos;/baixiu/04-baixiu/assets/vendors/&apos;, 3 配置模块的 路径和别名paths:&#123;jquery:&apos;jquery/jquery&apos;,template:&apos;template/template-web&apos;,wangEditor:&apos;wangEidtor/wangEditor&apos;,moment:&apos;moment/moment&apos;,posts:&apos;posts&apos;, 本身不支持模块化，但是有又依赖于jquerypagination:&apos;pagination/jquery.pagination&apos;,bootstrap:&apos;bootstrap/js/bootstrap&apos;&#125;, 给不支持模块化的第三方插件 指定依赖项shim:&#123; 给两个模块绑定依赖关系pagination:&#123;deps:[&apos;jquery&apos;] //依赖项一定是数组格式&#125;,bootstrap:&#123;deps:[&apos;jquery&apos;] //依赖项一定是数组格式&#125;&#125;&#125;); 12345678910- 引入模块require([&apos;posts&apos;],function()&#123;&#125;);只需引入posts 前提posts中要导入其他的插件+ define([&apos;template&apos;,&apos;moment&apos;,&apos;wangEditor&apos;,&apos;pagination&apos;,&apos;bootstrap&apos;],+ function(template,moment,wangEditor,pagination,bootstrap)&#123;+ 把$(function ) 换成define就行啦!!!!!","categories":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/categories/node-js/"}],"tags":[]},{"title":"node.js","slug":"node.js","date":"2018-04-21T14:47:43.000Z","updated":"2018-04-22T08:25:23.330Z","comments":true,"path":"2018/04/21/node.js/","link":"","permalink":"http://yoursite.com/2018/04/21/node.js/","excerpt":"","text":"##node.js process.stdout.write(“”) 标准输出 写文件 1fs.writeFile(&quot;文件路径&quot;，“文件的内容”，“文件编码格式”，回掉函数) 函数参数err 如果成功了，err是null 如果失败了，err是失败的信息 想用这个方法先要引入1var fs =require(&quot;fs&quot;); 只有global全局的内置方法才能直接使用，否则需要使用require定义才能使用 读文件 123fs.readFile(&quot;路径&quot;，“编码格式”，function（err,data）&#123; &#125;) 如果不传编码格式，读取的数据是一个buffer 对象，可以调用toString方法传递编码格式作为参数来转换 创建文件夹 123fs.mkdir(&quot;文件夹名&quot;，function（）&#123; &#125;) 同步创建文件 123fs.writeSync( &quot;文件名&quot;，“内容”)；console.log(66666) 由于是同步，不需要回调函数 结果是先创建文件才能读取666","categories":[],"tags":[]},{"title":"hexo命令","slug":"hello-world","date":"2018-04-19T14:41:18.870Z","updated":"2018-04-22T14:37:39.774Z","comments":true,"path":"2018/04/19/hello-world/","link":"","permalink":"http://yoursite.com/2018/04/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[]},{"title":"my new post","slug":"hexo创建博客日志","date":"2018-04-19T14:11:21.000Z","updated":"2018-04-22T14:37:55.804Z","comments":true,"path":"2018/04/19/hexo创建博客日志/","link":"","permalink":"http://yoursite.com/2018/04/19/hexo创建博客日志/","excerpt":"","text":"hexo创建博客安装步骤 npm安装的时候，默认会访问npmjs.org这个网站，国外的，把镜像地址改成了淘宝的。 修改npm镜像地址 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 安装hexo 123npm install -g hexo-clihexo -v # 查看hexo的版本信息 初始化博客 12# 新建一个目录 bloghexo init # 初始化 生成静态页面 12hexo generate # 生成静态页面 hexo g # 生成静态页面（简写） 启动服务 12hexo server # 启动服务hexo s # 启动服务(简写) 访问站点 1http://localhost:4000/ # 通过这个地址就可以访问了 hexo常见命令 hexo n &#39;博客标题&#39;创建一篇新的博客 hexo g 生成博客 hexo d 发布博客 hexo中文文档 hexo next主题文档 博客格式123456789101112---title: 我的第一篇博客//(注意冒号后面有一个空格不能丢。)date: 2018-04-02 01:12:29 //指定博客的日期tags: - 学习 - 随笔 - 心情categories: - javascript---# 我是大标题这后面的内容就跟普通的markdown文件没什么区别 发布配置安装hexo的部署工具npm install hexo-deployer-git --save 修改_config.yml文件 12345678910111213# Sitetitle: 网站标题subtitle: 子标题description: 无author: 作者名称language: zh-CNtimezone:# 发布配置deploy: type: git repo: github仓库地址 branch: master 使用hexo d发布博客","categories":[{"name":"git专题","slug":"git专题","permalink":"http://yoursite.com/categories/git专题/"}],"tags":[]}]}