{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"git命令","slug":"git命令","date":"2018-04-21T15:24:54.000Z","updated":"2018-04-21T15:25:25.791Z","comments":true,"path":"2018/04/21/git命令/","link":"","permalink":"http://yoursite.com/2018/04/21/git命令/","excerpt":"","text":"git 重置 reset –hard 版本号 重置了这个版本，在所有区域都重置了 将来不小心误操作了，提交了，可以回退某个版本 reset –soft 版本号 只重置了仓库区 reset –mixed 版本号 重置，只剩下工作区 把暂存区和仓库区都重置了 git 忽视文件（有的文件不希望git管理提交） 在文件目录中创建一个 .gitignore 把不想提交的文件名写在这个文件里即可 把自己也写进去 git 分支操作 git branch 查看分支，master是默认的主分支 分支其实本质上就是一个指针 当新提交了一个版本，当前的指针会指向最新生成的版本 当前颜色是绿色，有小菊花 创建分支 git branch login 新建一个登陆的分支 git branch 可以查看所有分支 git 中有一个HEAD指针永远指向当前分支 切换分支 git checkout login 切换分支为登陆的分支 在这之后，master分支都没有登陆功能，给客户看的时候就不会有bug 当登陆功能写完时，切换master分支 git checkout master 并且希望login的内容合并master分支上 git merge login 这样就何在一起了 删除分支 git branch -d login (前提login要切换到其他分支，并合并才能删除) 创建分支的步骤： 1：在写另一个功能不想被别人看到的时候先创建分支 git branch login 2:要把新建的分支指向这个功能 git chekout login 然后这个时候就可以开始写代码了,然后写的代码包括一开始写的代码（master阶段），如果切换到master分支时，不会显示login分支的内容 3：最后写完了 把分支指向主分支 git checkout master 4:最后要主分支master合并login即可 git merge login 这个时候login的内容和master一开始的内容就合并了 5：这个时候分支就可以删除了 git branch -d login; git checkout -b 分支名 创建并且切换 多个分支合并的冲突问题 git ：当先合并一个的时候，原理是指针会带着master指向那个分支，是祖辈分支可以快速合并，但是在继续合并其他分支的时候，由于分支带着master跑到了其他分支，再合并就不是祖辈关系了，导致合并冲突，不能快速合并 解决方案：删除冲突产生的符号标记，并删除，然后重新add commit 就行了 git对比# 查看工作区与暂存区的不同 git diff # 查看暂存区与仓库区的不同 git diff –cached # 查看工作区与仓库区的不同，HEAD表示最新的那次提交 git diff HEAD # 查看两个版本之间的不同 git diff c265262 de4845b github常见项目 克隆远程仓库 git clone 仓库地址 文件夹名称 提交到远程仓库 git push +地址 分支名（master） 提交过一次 再次提交可以把地址改为origin就行 （origin是克隆的时候保存下来的） git pull 获取远程仓库可以直接偷过来用 远程仓库的冲突问题； 假如好几个人上传同一个项目，远程仓库被修改了，在 git pull 下来的时候就会和一开始的代码不一样发生冲突 解决方案：删除冲突的符号并重新 add commit 最后 git pull 在验证一遍，在git push 就行了 git remote 查看地址的快捷名 git remote add bi别名 给地址增加其他的名字 SSH非对称加密 私钥 个人 公钥 GitHub","categories":[],"tags":[]},{"title":"前端模块化","slug":"hello-222","date":"2018-04-21T15:07:24.000Z","updated":"2018-04-21T15:23:55.762Z","comments":true,"path":"2018/04/21/hello-222/","link":"","permalink":"http://yoursite.com/2018/04/21/hello-222/","excerpt":"","text":"前端模块化前提在使用模块化之前，在当前页面引入插件require.js1: 定义模块：语法define（“模块名”，[依赖项]，function（）{模块的全部代码cosole(我是A模块哈哈)}）模块名一般建议不写，叫做匿名模块 还要起名字的叫做（具名模块）； 2:引入模块：语法require（[模块名，写明路径]），function（）{模块引入完成时调用 执行这里面的代码（异步）console。log（我是A模块哈哈）}）模块名不要.js后缀定义，并且引入过后，主要执行的结果是我是A模块哈哈我是A模块哈哈 但是 由于定于的模块是一个闭包，调用完成后就被销毁了，所以要有一种方法暴露出去 导出 即可。require（[模块名，写明路径]），function（）{**模块引入完成时调用 执行这里面的代码（异步）** var age=100;**function song(){**alert(6666);return{**age:age,**song:song};**//这样这个定义的模块就有了导出项，别人可以使用了，但是问题来了，别人怎么使用呢！！！**}）有导出项的模块怎么使用，即使用返回时，怎么拿到！！！ 在引入模块的回掉函数写一个形参require（[模块名，写明路径]），function（mk）{**mk.song();mk.age;}） mk就是一个形参，接收引进了模块暴露的数据，是一个对象 这样模块引进的同时，数据也可以调用结果就是6666 100** 4：引入多个模块，多个模块都有返回值，怎么解决！！require（[a,b,c]，function(a.b.c){ }）一般形参和数组中的模块是一一对应的，注意对应和顺序，有几个导出项，就要写几个形参 一般没有形参的可以用下划线表示优化，不用返回值的模块因日可以写在后面，这样这个模块的形参在最后就可以不写了!!! 5 依赖项define（“模块名”，[c]，function（mc）{mc.xxxxxxx(就可以用了)}）假如定义的是b模块 。C是依赖项，想用c的导出项，也是给一个形参 6 模块的路径一般像jQuery主流的插件 都是有导出项的 支持模块化的 路径很深的情况下不好找，于是有了方法require.config({基础路径：一般是网站的决定路径；baseUrl:’’paths:{ chajian:’’ chajian2:’’} })paths:{** chajian:’’**} 这一部分是的paths是配置的插件的路径chajian 这是自定义取的别名，防止真正的插件名字太长，可以替换的 后面的是 基础路径设置完成下面的相对路径 然后在导入插件的时候就可以用别名了require（[chajian,chajian2]，function(){ }） 假如有的插件不支持模块化，但是有要依赖项比如 bootstrap 和wangedtor 他俩不支持但是有依赖与jQuery给不支持模块化的第三方插件使用 require.config({基础路径：一般是网站的决定路径；baseUrl:’’paths:{ chajian:’’ chajian2:’’bootstrap:’’wangeidtor} })shim{ } 一个项目的总代码 //配置路径require.config({//公共的基础路径baseUrl:’/baixiu/04-baixiu/assets/vendors/‘,// 配置模块的 路径和别名paths:{jquery:’jquery/jquery’,template:’template/template-web’,wangEditor:’wangEidtor/wangEditor’,moment:’moment/moment’,posts:’posts’,//本身不支持模块化，但是有又依赖于jquerypagination:’pagination/jquery.pagination’,bootstrap:’bootstrap/js/bootstrap’},//给不支持模块化的第三方插件 指定依赖项shim:{//给两个模块绑定依赖关系pagination:{deps:[‘jquery’] //依赖项一定是数组格式},bootstrap:{deps:[‘jquery’] //依赖项一定是数组格式}}});//引入模块require([‘posts’],function(){});只需引入posts 前提posts中要导入其他的插件define([‘template’,’moment’,’wangEditor’,’pagination’,’bootstrap’],function(template,moment,wangEditor,pagination,bootstrap){把$(function ) 换成define就行啦!!!!!","categories":[],"tags":[]},{"title":"node.js","slug":"hello-wzc","date":"2018-04-21T14:47:43.000Z","updated":"2018-04-21T15:24:16.889Z","comments":true,"path":"2018/04/21/hello-wzc/","link":"","permalink":"http://yoursite.com/2018/04/21/hello-wzc/","excerpt":"","text":"node.js process.stdout.write(“”) 标准输出 写文件 fs.writeFile(“文件路径”，“文件的内容”，“文件编码格式”，回掉函数) 函数参数err 如果成功了，err是null 如果失败了，err是失败的信息 想用这个方法先要引入 var fs =require(“fs”); 只有global全局的内置方法才能直接使用，否则需要使用require定义才能使用 读文件 fs.readFile(“路径”，“编码格式”，function（err,data）{ }) 如果不传编码格式，读取的数据是一个buffer 对象，可以调用toString方法传递编码格式作为参数来转换 创建文件夹 fs.mkdir(“文件夹名”，function（）{ }) 同步创建文件 fs.writeSync( “文件名”，“内容”)； console.log(66666) 由于是同步，不需要回调函数 结果是先创建文件才能读取666","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-04-19T14:41:18.870Z","updated":"2018-04-19T14:41:18.871Z","comments":true,"path":"2018/04/19/hello-world/","link":"","permalink":"http://yoursite.com/2018/04/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"my new post","slug":"my-new-post","date":"2018-04-19T14:11:21.000Z","updated":"2018-04-19T14:41:18.872Z","comments":true,"path":"2018/04/19/my-new-post/","link":"","permalink":"http://yoursite.com/2018/04/19/my-new-post/","excerpt":"","text":"hexo创建博客安装步骤 npm安装的时候，默认会访问npmjs.org这个网站，国外的，把镜像地址改成了淘宝的。 修改npm镜像地址 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 安装hexo 123npm install -g hexo-clihexo -v # 查看hexo的版本信息 初始化博客 12# 新建一个目录 bloghexo init # 初始化 生成静态页面 12hexo generate # 生成静态页面 hexo g # 生成静态页面（简写） 启动服务 12hexo server # 启动服务hexo s # 启动服务(简写) 访问站点 1http://localhost:4000/ # 通过这个地址就可以访问了 hexo常见命令 hexo n &#39;博客标题&#39;创建一篇新的博客 hexo g 生成博客 hexo d 发布博客 hexo中文文档 hexo next主题文档 博客格式123456789101112---title: 我的第一篇博客//(注意冒号后面有一个空格不能丢。)date: 2018-04-02 01:12:29 //指定博客的日期tags: - 学习 - 随笔 - 心情categories: - javascript---# 我是大标题这后面的内容就跟普通的markdown文件没什么区别 发布配置安装hexo的部署工具npm install hexo-deployer-git --save 修改_config.yml文件 12345678910111213# Sitetitle: 网站标题subtitle: 子标题description: 无author: 作者名称language: zh-CNtimezone:# 发布配置deploy: type: git repo: github仓库地址 branch: master 使用hexo d发布博客","categories":[],"tags":[]}]}